<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构--栈</title>
    <url>/2019/11/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    <content><![CDATA[<h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈（stack）是限定仅在表尾进行插入或者删除操作的线性表。表尾端称为栈顶（top），表头端称为栈底（bottom），不含元素的空表称为空栈。</p>
<ul>
<li><p>栈的特点：后进先出（last in first out）</p>
</li>
<li><p>注意：由于栈的特点，并不是最先进栈就一定是最后出栈</p>
</li>
</ul>
<h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p>栈有九种基本的操作，下面的代码对应了这九种操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define OVERFLOW -2</span><br><span class="line">#define INFEASIBLE -1</span><br><span class="line">#define STACK_INIT_SIZE 100</span><br><span class="line">#define STACKINCREMENT 10</span><br><span class="line">typedef int Status;</span><br><span class="line">typedef int SElemType;</span><br><span class="line"></span><br><span class="line">//顺序栈的定义 </span><br><span class="line">typedef struct &#123;</span><br><span class="line">	SElemType * base;	//顺序栈的基址 </span><br><span class="line">	SElemType * top;	//顺序栈的位标，指向栈顶元素的下一位 </span><br><span class="line">	int stacksize;		//当前已经分配的储存空间，以元素为单位 </span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	构建一个空栈S：即要将顺序栈定义里的每个元素都指定明确的值 </span><br><span class="line">		1. 分配空间，stacksize长度</span><br><span class="line">		2. 改变top位标指向S的基址</span><br><span class="line">		3. 指明储存空间大小 </span><br><span class="line">*/</span><br><span class="line">Status InitStack(SqStack &amp;S)&#123;</span><br><span class="line">	S.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType));</span><br><span class="line">	if(!S.base)</span><br><span class="line">		exit(OVERFLOW);</span><br><span class="line">	S.top = S.base;</span><br><span class="line">	S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">	return OK;		</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	销毁栈S,即S不再存在</span><br><span class="line">		1. top位标置空</span><br><span class="line">		2. stacksize置零</span><br><span class="line">		3. 释放顺序栈空间 </span><br><span class="line">*/</span><br><span class="line">Status DestroyStack(SqStack &amp;S)&#123;</span><br><span class="line">	S.top = NULL;</span><br><span class="line">	S.stacksize = 0;</span><br><span class="line">	free(S.base);</span><br><span class="line">	return OK; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	清空栈S元素,S仍然存在</span><br><span class="line">		1. S.top指向S.base </span><br><span class="line">*/</span><br><span class="line">Status ClearStack(SqStack &amp;S)&#123;</span><br><span class="line">	S.top = S.base;</span><br><span class="line">	return OK;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	顺序栈的判空操作，若为空栈，返回TRUE，否则返回FALSE</span><br><span class="line">		1. 判断S.top是否指向S.base </span><br><span class="line">*/</span><br><span class="line">Status StackEmpty(SqStack S)&#123;</span><br><span class="line">	if(S.base == S.top)</span><br><span class="line">		return TRUE;</span><br><span class="line">	return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	返回S的长度</span><br><span class="line">		1. 直接用位标相减 </span><br><span class="line">*/</span><br><span class="line">int StackLength(SqStack S)&#123;</span><br><span class="line">	if(S.base == S.top)</span><br><span class="line">		return ERROR;</span><br><span class="line">	return (S.top - S.base); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	查看栈顶元素e</span><br><span class="line">		1. 注意top指向的是栈顶元素的下一位</span><br><span class="line">*/</span><br><span class="line">Status GetTop(SqStack S, SElemType &amp;e)&#123;</span><br><span class="line">	if(S.base == S.top)</span><br><span class="line">		return ERROR;</span><br><span class="line">	e = *(S.top - 1);	</span><br><span class="line">	return OK;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	插入e作为新的栈顶元素</span><br><span class="line">		1. 若插入之前栈满，则先扩容，用realloc，同时也要改变top和stacksize </span><br><span class="line">		2. 若未满，直接插入		</span><br><span class="line">*/</span><br><span class="line">Status Push(SqStack &amp;S, SElemType e)&#123;</span><br><span class="line">	if((S.top - S.base) &gt;= S.stacksize) &#123;</span><br><span class="line">		S.base = (SElemType *)realloc(S.base,</span><br><span class="line">				(S.stacksize + STACKINCREMENT) * sizeof(SElemType));</span><br><span class="line">		if(!S.base)</span><br><span class="line">			exit(OVERFLOW);		//存储分配失败 </span><br><span class="line">		S.top = S.base + S.stacksize;	//S.base的地址可能发生改变，要重新定址 </span><br><span class="line">		S.stacksize += STACKINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	*S.top++ = e;</span><br><span class="line">	return OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	删除栈顶元素，用e返回其值</span><br><span class="line">		1. 获取栈顶元素后，top往前移一位	</span><br><span class="line">*/</span><br><span class="line">Status Pop(SqStack &amp;S, SElemType &amp;e)&#123;</span><br><span class="line">	if(S.base == S.top)</span><br><span class="line">		return ERROR;</span><br><span class="line">	e = *(--S.top);		//先移再用,其实并没有真正删除栈顶元素，只是指针移位了 </span><br><span class="line">	return OK; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	遍历栈</span><br><span class="line">		1. 从栈顶开始遍历，不能移动S.top位标，要另外定义一个p结点作为标记 </span><br><span class="line">*/</span><br><span class="line">Status StackTraverse(SqStack S)&#123;</span><br><span class="line">	if(S.base == NULL)</span><br><span class="line">		return ERROR;</span><br><span class="line">	if(S.top == S.base)</span><br><span class="line">		printf(&quot;顺序栈中没有元素，是空栈...&quot;);</span><br><span class="line">	SElemType *p;</span><br><span class="line">	p = S.top;</span><br><span class="line">	while(p &gt; S.base)</span><br><span class="line">	&#123;</span><br><span class="line">		p--;</span><br><span class="line">		printf(&quot;%d\t&quot;, *p);</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">		 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	printf(&quot;构建一个空栈S...\n&quot;);</span><br><span class="line">	if(InitStack(S))</span><br><span class="line">		printf(&quot;构建成功!\n&quot;);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;构建失败!\n&quot;);</span><br><span class="line">	printf(&quot;====================\n&quot;); </span><br><span class="line">	printf(&quot;判断S是否为空栈...\n&quot;);</span><br><span class="line">	if(StackEmpty(S))</span><br><span class="line">		printf(&quot;该栈为空栈！\n&quot;);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;该栈不是空栈！\n&quot;);</span><br><span class="line">	printf(&quot;====================\n&quot;);</span><br><span class="line">	int i,n ;</span><br><span class="line">    printf(&quot;输入栈的长度:\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;输入栈的第%d个元素\n&quot;,i);</span><br><span class="line">        ++S.top;</span><br><span class="line">        scanf(&quot;%d&quot;,S.top-1);</span><br><span class="line">    &#125; </span><br><span class="line">    printf(&quot;====================\n&quot;);</span><br><span class="line">    printf(&quot;判断S是否为空栈...\n&quot;);</span><br><span class="line">	if(StackEmpty(S))</span><br><span class="line">		printf(&quot;该栈为空栈！\n&quot;);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;该栈不是空栈！\n&quot;);</span><br><span class="line">	printf(&quot;====================\n&quot;);</span><br><span class="line">	int e;</span><br><span class="line">	printf(&quot;输出栈顶元素...\n&quot;);</span><br><span class="line">	GetTop(S, e);</span><br><span class="line">	printf(&quot;%d\n&quot;, e); </span><br><span class="line">	printf(&quot;====================\n&quot;);</span><br><span class="line">	printf(&quot;遍历输出栈的所有元素...\n&quot;);</span><br><span class="line">	StackTraverse(S);</span><br><span class="line">	printf(&quot;\n&quot;); </span><br><span class="line">	printf(&quot;====================\n&quot;);</span><br><span class="line">	printf(&quot;计算该栈的长度...\n&quot;);</span><br><span class="line">	printf(&quot;S的长度为%d\n&quot;, StackLength(S));</span><br><span class="line">	printf(&quot;====================\n&quot;);</span><br><span class="line">	printf(&quot;插入元素k...\n&quot;);</span><br><span class="line">	int k = 90;</span><br><span class="line">	Push(S, k);</span><br><span class="line">	printf(&quot;====================\n&quot;);</span><br><span class="line">	printf(&quot;遍历输出栈的所有元素...\n&quot;);</span><br><span class="line">	StackTraverse(S);</span><br><span class="line">	printf(&quot;\n&quot;); </span><br><span class="line">	printf(&quot;====================\n&quot;);</span><br><span class="line">	printf(&quot;删除栈顶元素...\n&quot;);</span><br><span class="line">	Pop(S, e);</span><br><span class="line">	printf(&quot;====================\n&quot;);</span><br><span class="line">	printf(&quot;遍历输出栈的所有元素...\n&quot;);</span><br><span class="line">	StackTraverse(S);</span><br><span class="line">	printf(&quot;\n&quot;); </span><br><span class="line">	printf(&quot;====================\n&quot;);</span><br><span class="line">	printf(&quot;清空栈...\n&quot;);</span><br><span class="line">	ClearStack(S);</span><br><span class="line">	printf(&quot;====================\n&quot;);</span><br><span class="line">	printf(&quot;遍历输出栈的所有元素...\n&quot;);</span><br><span class="line">	StackTraverse(S);</span><br><span class="line">	printf(&quot;\n&quot;); </span><br><span class="line">	printf(&quot;====================\n&quot;);</span><br><span class="line">	printf(&quot;销毁栈...\n&quot;);</span><br><span class="line">	DestroyStack(S);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果如下：</span><br><span class="line">构建一个空栈S...</span><br><span class="line">构建成功!</span><br><span class="line">====================</span><br><span class="line">判断S是否为空栈...</span><br><span class="line">该栈为空栈！</span><br><span class="line">====================</span><br><span class="line">输入栈的长度:</span><br><span class="line">4</span><br><span class="line">输入栈的第1个元素</span><br><span class="line">34</span><br><span class="line">输入栈的第2个元素</span><br><span class="line">57</span><br><span class="line">输入栈的第3个元素</span><br><span class="line">128</span><br><span class="line">输入栈的第4个元素</span><br><span class="line">3456</span><br><span class="line">====================</span><br><span class="line">判断S是否为空栈...</span><br><span class="line">该栈不是空栈！</span><br><span class="line">====================</span><br><span class="line">输出栈顶元素...</span><br><span class="line">3456</span><br><span class="line">====================</span><br><span class="line">遍历输出栈的所有元素...</span><br><span class="line">3456    128     57      34</span><br><span class="line">====================</span><br><span class="line">计算该栈的长度...</span><br><span class="line">S的长度为4</span><br><span class="line">====================</span><br><span class="line">插入元素k...</span><br><span class="line">====================</span><br><span class="line">遍历输出栈的所有元素...</span><br><span class="line">90      3456    128     57      34</span><br><span class="line">====================</span><br><span class="line">删除栈顶元素...</span><br><span class="line">====================</span><br><span class="line">遍历输出栈的所有元素...</span><br><span class="line">3456    128     57      34</span><br><span class="line">====================</span><br><span class="line">清空栈...</span><br><span class="line">====================</span><br><span class="line">遍历输出栈的所有元素...</span><br><span class="line">顺序栈中没有元素，是空栈...</span><br><span class="line">====================</span><br><span class="line">销毁栈...</span><br></pre></td></tr></table></figure>

<h2 id="栈与递归的实现"><a href="#栈与递归的实现" class="headerlink" title="栈与递归的实现"></a>栈与递归的实现</h2><ol>
<li><p>hanoi问题</p>
<p>古代有一个梵塔，塔内有3个座A,B,C，开始时A座有n个盘子，盘子大小不等，大的在下，小的在上。有一个老和尚想把这n个盘子，从A座移动到C座，但是每次只允许移动一个盘子，且在移动的过程中，3个座上都始终保持大盘在下，小盘在上。在移动的过程中，可以利用B座。 </p>
<ul>
<li><p>解决思路：当n = 1时，直接将编号1的盘子从X移到Z即可；当n &gt; 1时， 则先经过一系列步骤将n - 1 个盘子移到Y处，然后将编号n的盘子从X移到Z，最后将Y中的n - 1个盘子经过一系列步骤从Y移到Z上；如何将n - 1个盘子从一个塔移到另一个塔的问题是和原问题具有相同特征的问 题，只需递归调用自身即可。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void move(char x, int n, char z)&#123;</span><br><span class="line">	printf(&quot;Move disk %d from %c to %c\n&quot;, n, x, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hanoi(int n, char x, char y, char z)&#123;</span><br><span class="line">	if(n == 1)</span><br><span class="line">		move(x, 1, z);			//将编号为1的盘子从x移到z</span><br><span class="line">	else&#123;</span><br><span class="line">		hanoi(n - 1, x, z, y);	//将x上编号为1至n - 1的盘子移到y,而z作辅佐塔</span><br><span class="line">		move(x, n, z);			//将编号为n的盘子从x移到z</span><br><span class="line">		hanoi(n - 1, y, x, z);	//将y上编号为1至n - 1的盘子移到z,而x作辅佐塔</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	hanoi(3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">Move disk 1 from a to c</span><br><span class="line">Move disk 2 from a to b</span><br><span class="line">Move disk 1 from c to b</span><br><span class="line">Move disk 3 from a to c</span><br><span class="line">Move disk 1 from b to a</span><br><span class="line">Move disk 2 from b to c</span><br><span class="line">Move disk 1 from a to c</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数调用过程中的递归</p>
<p>当有多个函数构成嵌套调用时，按照“后调用先返回”的原则，系统将这个程序运行所需的数据空间安排在一个栈中，当调用一个函数时，就在栈顶为它分配一个储存区，当一个函数退出时，就释放它的储存区，则当前正运行的函数必在栈顶。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2019/11/13/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="反射的一些基础知识"><a href="#反射的一些基础知识" class="headerlink" title="反射的一些基础知识"></a>反射的一些基础知识</h1><h3 id="反射机制图"><a href="#反射机制图" class="headerlink" title="反射机制图"></a>反射机制图</h3><p><img src="/images/%E5%8F%8D%E5%B0%84.bmp" alt="反射"></p>
<h3 id="什么是Java反射"><a href="#什么是Java反射" class="headerlink" title="什么是Java反射"></a>什么是Java反射</h3><p>​         JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的以及动态调用对象的方法的功能称为Java的反射机制。 </p>
<h3 id="获取Class对象的方式"><a href="#获取Class对象的方式" class="headerlink" title="获取Class对象的方式"></a>获取Class对象的方式</h3><ol>
<li>在编译阶段，用Class.forName(全包名)方式</li>
<li>在类加载器ClassLoader中，用类名.class获取</li>
<li>在程序运行阶段，用对象.getClass()获取</li>
</ol>
<ul>
<li>注意：同一个字节码文件（###.class）在一次程序运行的过程中只会被加载一次，不论通过哪种方式获取的Class对象都是同一个。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.Class.forname(&quot;全包名&quot;)</span><br><span class="line">//编译阶段</span><br><span class="line">Class class1 = Class.forName(&quot;ReflectPackage.Person.Person&quot;);</span><br><span class="line">System.out.println(class1);</span><br><span class="line"></span><br><span class="line">//2.类名.class</span><br><span class="line">//在类加载器ClassLoader中</span><br><span class="line">Class class2 = Person.class;</span><br><span class="line">System.out.println(class2);</span><br><span class="line"></span><br><span class="line">//3.对象.getClass()</span><br><span class="line">//Runtime运行阶段</span><br><span class="line">Person person = new Person();</span><br><span class="line">Class class3 = person.getClass();</span><br><span class="line">System.out.println(class3);</span><br><span class="line"></span><br><span class="line">System.out.println(class1 == class2);</span><br><span class="line">System.out.println(class1 == class3);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ReflectPackage.Person.Person</span><br><span class="line">class ReflectPackage.Person.Person</span><br><span class="line">class ReflectPackage.Person.Person</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<h3 id="使用Class对象"><a href="#使用Class对象" class="headerlink" title="使用Class对象"></a>使用Class对象</h3><h4 id="Field对象"><a href="#Field对象" class="headerlink" title="Field对象"></a>Field对象</h4><ol>
<li>首先创建一个Person类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ReflectPackage.Person;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对Field对象基本操作就是set,get</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ReflectPackage.MainTest02;</span><br><span class="line"></span><br><span class="line">import ReflectPackage.Student.Student;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class MainTest02 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //操作Class对象的成员变量</span><br><span class="line">        //1.getFields()</span><br><span class="line">        //只能获取public对象</span><br><span class="line">        Class studentClass = Student.class;</span><br><span class="line">        Field[] fields = studentClass.getFields();</span><br><span class="line">        for (Field  field: fields ) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;==============&quot;);</span><br><span class="line">        //2.getField()</span><br><span class="line">        Field student1 = studentClass.getField(&quot;name01&quot;);</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student1.set(student, &quot;kalwae&quot;);</span><br><span class="line">        Object o = student1.get(student);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(&quot;==============&quot;);</span><br><span class="line">        //3.getDeclaredFields()</span><br><span class="line">        Field[] declaredFields = studentClass.getDeclaredFields();</span><br><span class="line">        for (Field f: declaredFields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;==============&quot;);</span><br><span class="line">        //4.getDeclaredField()</span><br><span class="line">        Field name02 = studentClass.getDeclaredField(&quot;name02&quot;);</span><br><span class="line">        name02.setAccessible(true);//暴力反射</span><br><span class="line">        name02.set(student, &quot;lisi&quot;);</span><br><span class="line">        Object o1 = name02.get(student);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>对getFields方法来说，只能获取public变量，而getDeclaredFields方法，则能获取Person类中的所有对象。如果要对private变量进行set操作，要使用暴力反射，即调用Field对象的setAccessible方法，设为true。</p>
<p>运行结果：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public java.lang.String ReflectPackage.Student.Student.name01</span><br><span class="line">public int ReflectPackage.Student.Student.age01</span><br><span class="line">==============</span><br><span class="line">kalwae</span><br><span class="line">==============</span><br><span class="line">public java.lang.String ReflectPackage.Student.Student.name01</span><br><span class="line">public int ReflectPackage.Student.Student.age01</span><br><span class="line">private java.lang.String ReflectPackage.Student.Student.name02</span><br><span class="line">private int ReflectPackage.Student.Student.age02</span><br><span class="line">==============</span><br><span class="line">lisi</span><br></pre></td></tr></table></figure>

<h4 id="Constructor对象"><a href="#Constructor对象" class="headerlink" title="Constructor对象"></a>Constructor对象</h4><ol>
<li>同样使用之前定义好的Person类，对Constructor对象，基本操作就是用newInstance方法创建对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ReflectPackage.MainTest03;</span><br><span class="line"></span><br><span class="line">import ReflectPackage.Student.Student;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line">public class MainTest03 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class studentClass = Student.class;</span><br><span class="line">        //1.getConstructor(有参)</span><br><span class="line">        Constructor constructor = studentClass.getConstructor(String.class, 				int.class, String.class, int.class);</span><br><span class="line">        Object o = constructor.newInstance(&quot;zhangsan&quot;, 13, &quot;lisi&quot;, 24);</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;===========&quot;);</span><br><span class="line">        //2.getConstructor(无参)</span><br><span class="line">        Constructor constructor1 = studentClass.getConstructor();</span><br><span class="line">        Object o1 = constructor1.newInstance();</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        //可以简化</span><br><span class="line">        //Class类中有newInstance()方法</span><br><span class="line">        Object o2 = studentClass.newInstance();</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行结果：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student&#123;name01=&apos;zhangsan&apos;, age01=13, name02=&apos;lisi&apos;, age02=24&#125;</span><br><span class="line">===========</span><br><span class="line">Student&#123;name01=&apos;null&apos;, age01=0, name02=&apos;null&apos;, age02=0&#125;</span><br><span class="line">Student&#123;name01=&apos;null&apos;, age01=0, name02=&apos;null&apos;, age02=0&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Method对象"><a href="#Method对象" class="headerlink" title="Method对象"></a>Method对象</h4><ol>
<li>先创建一个Student类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ReflectPackage.Student;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">    public String name01;</span><br><span class="line">    public int age01;</span><br><span class="line"></span><br><span class="line">    private String name02;</span><br><span class="line">    private int age02;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;name01=&apos;&quot; + name01 + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age01=&quot; + age01 +</span><br><span class="line">                &quot;, name02=&apos;&quot; + name02 + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age02=&quot; + age02 +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName01() &#123;</span><br><span class="line">        return name01;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName01(String name01) &#123;</span><br><span class="line">        this.name01 = name01;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge01() &#123;</span><br><span class="line">        return age01;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge01(int age01) &#123;</span><br><span class="line">        this.age01 = age01;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName02() &#123;</span><br><span class="line">        return name02;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName02(String name02) &#123;</span><br><span class="line">        this.name02 = name02;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge02() &#123;</span><br><span class="line">        return age02;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge02(int age02) &#123;</span><br><span class="line">        this.age02 = age02;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(String name01, int age01, String name02, int age02) &#123;</span><br><span class="line">        this.name01 = name01;</span><br><span class="line">        this.age01 = age01;</span><br><span class="line">        this.name02 = name02;</span><br><span class="line">        this.age02 = age02;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;eat...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eating(String food)&#123;</span><br><span class="line">        System.out.println(&quot;eating some&quot; + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可以利用Method对象，调用Student对象的成员方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ReflectPackage.MainTest04;</span><br><span class="line"></span><br><span class="line">import ReflectPackage.Student.Student;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class MainTest04 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class studentClass = Student.class;</span><br><span class="line">        //1.getMethod</span><br><span class="line">        Method method = studentClass.getMethod(&quot;eat&quot;);</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        method.invoke(student);</span><br><span class="line">        Method eating = studentClass.getMethod(&quot;eating&quot;, String.class);</span><br><span class="line">        eating.invoke(student, &quot;rice&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;===========&quot;);</span><br><span class="line">        //2.getMethods</span><br><span class="line">        Method[] methods = studentClass.getMethods();</span><br><span class="line">        for (Method m:methods</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(m);//输出所有public方法和Object方法</span><br><span class="line">        &#125;</span><br><span class="line">        //如果有私有方法，也可以用暴力反射，Method对象.setAccessible()</span><br><span class="line"></span><br><span class="line">        //获取类名</span><br><span class="line">        System.out.println(&quot;===========&quot;);</span><br><span class="line">        String name = studentClass.getName();</span><br><span class="line">        System.out.println(name);//ReflectPackage.Student.Student</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行结果：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eat...</span><br><span class="line">eating somerice</span><br><span class="line">===========</span><br><span class="line">public java.lang.String ReflectPackage.Student.Student.toString()</span><br><span class="line">public void ReflectPackage.Student.Student.eating(java.lang.String)</span><br><span class="line">public void ReflectPackage.Student.Student.eat()</span><br><span class="line">public void ReflectPackage.Student.Student.setAge01(int)</span><br><span class="line">public void ReflectPackage.Student.Student.setName01(java.lang.String)</span><br><span class="line">public void ReflectPackage.Student.Student.setAge02(int)</span><br><span class="line">public int ReflectPackage.Student.Student.getAge01()</span><br><span class="line">public java.lang.String ReflectPackage.Student.Student.getName01()</span><br><span class="line">public java.lang.String ReflectPackage.Student.Student.getName02()</span><br><span class="line">public void ReflectPackage.Student.Student.setName02(java.lang.String)</span><br><span class="line">public int ReflectPackage.Student.Student.getAge02()</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">===========</span><br><span class="line">ReflectPackage.Student.Student</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之DQL</title>
    <url>/2019/11/12/MySQL%E4%B9%8BDQL/</url>
    <content><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">    字段列表  </span><br><span class="line">from</span><br><span class="line">    表名列表</span><br><span class="line">where</span><br><span class="line">    条件列表</span><br><span class="line">group by</span><br><span class="line">    分组列表</span><br><span class="line">having</span><br><span class="line">    分组之后的条件</span><br><span class="line">order by</span><br><span class="line">    排序</span><br><span class="line">limit</span><br><span class="line">    分页限定</span><br></pre></td></tr></table></figure>
<h1 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h1><ol>
<li>查询多个字段<br><code>select 字段名1,... from 表名;</code>  <ul>
<li>查询所有字段<br><code>select * from 表名;</code>  </li>
</ul>
</li>
<li>去除重复的结果<br><code>select distinct 字段名 from 表名;</code>  </li>
</ol>
<ul>
<li>有多个字段名时，只有各行数据完全相同才去重  </li>
</ul>
<ol start="3">
<li>列求和<br><code>select 列名1+列名2 from 表名;</code>  </li>
</ol>
<ul>
<li>如果有null参与的运算，结果全为null  </li>
<li><code>ifnull()函数</code><br>  <code>select ifnull(含null的列,替换成的值) from 表名;</code>  <h1 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h1>where 条件  </li>
</ul>
<ol>
<li>关系运算符：&gt;, &lt;, &gt;=, &lt;=, =, （两个不等于）!=, &lt;&gt;  </li>
<li>与：&amp;&amp;, and, between…and…  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">age &gt;= 20 &amp;&amp; age &lt;= 30</span><br><span class="line">age &gt;= 20 and age &lt;= 30</span><br><span class="line">age between 20 and 30</span><br></pre></td></tr></table></figure></li>
<li>或  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">age = 20 or age = 30 or age = 15</span><br><span class="line">age in(20, 30, 15)</span><br></pre></td></tr></table></figure></li>
<li>null值不能使用=（!=）判断  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字段 is null</span><br><span class="line">字段 is not null</span><br></pre></td></tr></table></figure>
<h1 id="模糊查询-like"><a href="#模糊查询-like" class="headerlink" title="模糊查询(like)"></a>模糊查询(like)</h1></li>
</ol>
<ul>
<li>占位符<br>‘_’表示单个字符<br>‘%’表示多个字符  </li>
<li>where 字段 like ‘…’<h1 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h1></li>
</ul>
<ul>
<li><code>order by 排序字段1 排序方式1， 排序字段2 排序方式2，......</code><br><code>select * from stu order by math asc/desc;</code>  </li>
</ul>
<blockquote>
<p>asc : 升序</p>
<p>desc : 降序  </p>
<p>如果不加这两个限定符，则默认用升序  </p>
</blockquote>
<ul>
<li><p>要对多个字段都排序，当前面的条件满足时，才会去判断第二条件<br><code>select * from stu order by math asc,english desc;</code>  </p>
<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><blockquote>
<p>将一列数据作为一个整体，进行纵向的计算  </p>
</blockquote>
</li>
<li><p>聚合函数会排除null值  </p>
<ul>
<li>解1：ifnull函数<br>  <code>select count(ifnull(english,0)) from stu;</code></li>
<li>解2：选择不含null的列计算<br>  <code>count(*)</code>  <blockquote>
<p>count():计算个数<br>max():最大值<br>min():最小值<br>sum():求和<br>avg():平均数 </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><ol>
<li>分组查询的字段：分组字段，聚合函数<br><code>select sex,avg(math),count(id) from stu group by sex;</code>  </li>
<li>where和having的区别<br> 1.where在分组前进行限定，如果不满足条件，则不参与分组；having在分组后进行限定，如果不满足条件，则不会被查询出来  <ol start="2">
<li>where后不可以跟聚合函数，having后可以进行聚合函数的判断 <h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><code>limit 开始的所有，每页查询的条数;</code><br>公式：开始的所引 = （当前页码 - 1） * 每页显示的条数  </li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>DQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之DML</title>
    <url>/2019/11/12/MySQL%E4%B9%8BDML/</url>
    <content><![CDATA[<h1 id="MySQL之DML"><a href="#MySQL之DML" class="headerlink" title="MySQL之DML"></a>MySQL之DML</h1><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p><code>insert into tableName(columnName1,...,columnNamen) values(value1,...valuen);</code>    </p>
<ul>
<li>注意：  <ol>
<li>如果表名后不定义列名，则默认给所有列添加        值。  </li>
<li>除了数字类型，其他数据类型加引号（单双都行）。  <h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><code>delete from tableName [where 条件];</code>    </li>
</ol>
</li>
<li>注意：  <ol>
<li>[…]中的内容可以省略，如果不加条件，则删除表中所有的记录。  </li>
<li>可以使用<code>truncate table tableName;</code><br> (重建一张具有相同列名的空表)。<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><code>update tableName set columnName1 = value1,...,columnNamen = valuen [where 条件];</code>  </li>
</ol>
</li>
<li>注意：  <ol>
<li>如果不加条件，则表中所有记录全部修改。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>DML</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之DDL</title>
    <url>/2019/11/12/MySQL%E4%B9%8BDDL/</url>
    <content><![CDATA[<h1 id="MySQL之DDL"><a href="#MySQL之DDL" class="headerlink" title="MySQL之DDL"></a>MySQL之DDL</h1><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><ol>
<li>create：创建<ul>
<li>创建新数据库db<br>  <code>create database db;</code></li>
<li>判断数据库不存在，再创建<br>  <code>create database if not exists db;</code></li>
<li>创建数据库并指定字符集<br>  <code>create database db character set gbk;</code>  </li>
</ul>
</li>
</ol>
<ul>
<li>注意：字符集写成==utf8==,不能是utf-8</li>
</ul>
<ol start="2">
<li>retrieve:查询<ul>
<li>查询所有数据库的名称<br>  <code>show databases;</code></li>
<li>查询某个数据库的字符集<br>  <code>show create database db;</code></li>
</ul>
</li>
<li>update:修改<ul>
<li>修改数据库的字符集<br>  <code>alter database db character set utf8;</code></li>
</ul>
</li>
<li>delete:删除<ul>
<li>删除数据库<br>  <code>drop database db;</code></li>
<li>先判断数据库存在再删除<br>  <code>drop database if exists db;</code>  </li>
</ul>
</li>
<li>使用数据库  <ul>
<li>查询正在使用的数据库名称<br>  <code>select database();</code>  </li>
<li>使用数据库<br>  <code>use db;</code><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2></li>
</ul>
</li>
<li>创建表<br> <code>create table tableName(</code><br> <code>列名1 数据类型1,</code><br> <code>列名2 数据类型2,</code><br> <code>...</code><br> <code>列名n 数据类型n</code><br> <code>);</code>  </li>
<li>查询表  <ul>
<li>查询某个数据库中所有的表名称<br>  <code>show tables;</code>  </li>
<li>查询表结构<br>  <code>desc tableName;</code>  </li>
<li>查询表中使用的字符集<br>  <code>show create table tableName;</code>  </li>
</ul>
</li>
<li>删除表  <ul>
<li>删除数据表<br>  <code>drop table tableName;</code>  </li>
<li>判断存在后再删除<br>  <code>drop table if exists tableName;</code>  </li>
</ul>
</li>
<li>修改表  <ul>
<li>修改表名<br>  <code>alter table tableName rename to newTableName;</code>  </li>
<li>修改表的字符集<br>  <code>alter table tableName character set gbk;</code>  </li>
<li>添加一列<br>  <code>alter table tableName add columnName dataType;</code>  </li>
<li>修改列名称、数据类型  <ol>
<li>列名和数据类型都修改：<code>alter table tableName change columnName newColumnName dataType;</code>  </li>
<li>只修改数据类型：<code>alter table tableName modify columnName dataType;</code>  </li>
</ol>
</li>
<li>删除列<br>  <code>alter table tableName drop columnName;</code>  </li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>DDL</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体</title>
    <url>/2019/11/12/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h2 id="结构体声明"><a href="#结构体声明" class="headerlink" title="结构体声明"></a>结构体声明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> title[<span class="number">41</span>];</span><br><span class="line">	<span class="keyword">char</span> author[<span class="number">31</span>];</span><br><span class="line">	<span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>该声明并未创建实际的数据对象，只是描述了该对象由什么组成。  </li>
<li>该声明后的”;”是必须有的，表示结构布局定义结束。  </li>
<li>该声明放在函数内外均可，若放在一个函数内，它的标识只能在函数内部使用，放在函数外部，则声明后的所有函数都能使用。  </li>
</ul>
<hr>
<blockquote>
<p>struct book library; </p>
<ul>
<li>将library声明为一个使用book结构布局的结构变量。  <h2 id="定义结构变量"><a href="#定义结构变量" class="headerlink" title="定义结构变量"></a>定义结构变量</h2>struct book a, b, * c;    </li>
<li>从本质上看，创建了一个名为<code>struct book</code>的新类型。  </li>
<li>该新类型的内存形式相当于将结构体内所有成员的内存合并在一起。  </li>
</ul>
<h2 id="初始化结构体"><a href="#初始化结构体" class="headerlink" title="初始化结构体"></a>初始化结构体</h2></blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> = &#123;</span></span><br><span class="line">	<span class="string">"Thinking in C"</span>,</span><br><span class="line">	<span class="string">"张浩"</span>,</span><br><span class="line">	<span class="string">"19"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C99和C11为结构体提供了指定初始化器  </p>
<ul>
<li>只是初始化book结构的value成员<br>  <code>struct book surprise = {.value = 19.98};</code></li>
<li>可以按照任意顺序指定初始化器    <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">gift</span> = &#123;</span></span><br><span class="line">.value = <span class="number">25.99</span>,</span><br><span class="line">.author = <span class="string">"James Broadfool"</span>,</span><br><span class="line">.title = <span class="string">"Rue for the Toad"</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">library.title;</span><br><span class="line">library.author;</span><br><span class="line">library.value;</span><br></pre></td></tr></table></figure></li>
<li>本质上，<code>.title</code>,<code>.author</code>,<code>.value</code>的作用相当于book结构的下标。  </li>
<li>需要访问<code>library.value</code>的地址时用<code>&amp;library.value</code><br>  (“.”的优先级比”&amp;”高)  <h2 id="结构体的嵌套结构"><a href="#结构体的嵌套结构" class="headerlink" title="结构体的嵌套结构"></a>结构体的嵌套结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * msgs[<span class="number">5</span>] = </span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"   Thank you for the wonderful evening,"</span>,</span><br><span class="line">	<span class="string">"You certainly prove that a "</span>,</span><br><span class="line">	<span class="string">"is a special kind of guy .We must get together"</span>,</span><br><span class="line">	<span class="string">"over a delicious "</span>,</span><br><span class="line">	<span class="string">" and have a few laughs"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> first[LEN];</span><br><span class="line">	<span class="keyword">char</span> last[LEN]; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">handle</span>;</span></span><br><span class="line">	<span class="keyword">char</span> favfood[LEN];</span><br><span class="line">	<span class="keyword">char</span> job[LEN];</span><br><span class="line">	<span class="keyword">float</span> income;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">guy</span> <span class="title">fellow</span> = &#123;</span></span><br><span class="line">		&#123;<span class="string">"Ewen"</span>, <span class="string">"Villard"</span>&#125;,</span><br><span class="line">		<span class="string">"grilled salmon"</span>,</span><br><span class="line">		<span class="string">"personality coach"</span>,</span><br><span class="line">		<span class="number">68112.00</span></span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Dear %s,  \n\n"</span>, fellow.handle.first);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s%s.\n"</span>, msgs[<span class="number">0</span>], fellow.handle.first);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s%s\n"</span>, msgs[<span class="number">1</span>], fellow.job);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, msgs[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s%s%s"</span>, msgs[<span class="number">3</span>], fellow.favfood, msgs[<span class="number">4</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(fellow.income &gt; <span class="number">150000.0</span>)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"!!"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(fellow.income &gt; <span class="number">75000.0</span>)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"!"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n%40s%s\n"</span>, <span class="string">" "</span>, <span class="string">"See you soon,"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%40s%s\n"</span>, <span class="string">" "</span>, <span class="string">"Shalala"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">Dear Ewen,</span><br><span class="line"></span><br><span class="line">   Thank you <span class="keyword">for</span> the wonderful evening,Ewen.</span><br><span class="line">You certainly prove that a personality coach</span><br><span class="line">is a special kind of guy .We must <span class="built_in">get</span> together</span><br><span class="line">over a delicious grilled salmon <span class="keyword">and</span> have a few laughs.</span><br><span class="line"></span><br><span class="line">                                        See you soon,</span><br><span class="line">                                        Shalala</span><br></pre></td></tr></table></figure>
<h2 id="声明结构数组"><a href="#声明结构数组" class="headerlink" title="声明结构数组"></a>声明结构数组</h2><code>struct book library[n];</code>  </li>
<li>注意：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">library             <span class="comment">//一个book结构的数组</span></span><br><span class="line">library[<span class="number">2</span>]          <span class="comment">//一个数组元素，该元素是book结构  </span></span><br><span class="line">library[<span class="number">2</span>].title    <span class="comment">//一个char数组（library[2]的title成员）</span></span><br><span class="line">library[<span class="number">2</span>].title[<span class="number">4</span>] <span class="comment">//数组中library[2]元素的title成员的一个字符</span></span><br></pre></td></tr></table></figure>
<h2 id="指向结构体的指针"><a href="#指向结构体的指针" class="headerlink" title="指向结构体的指针"></a>指向结构体的指针</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> first[LEN];</span><br><span class="line">	<span class="keyword">char</span> last[LEN]; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">handle</span>;</span></span><br><span class="line">	<span class="keyword">char</span> favfood[LEN];</span><br><span class="line">	<span class="keyword">char</span> job[LEN];</span><br><span class="line">	<span class="keyword">float</span> income;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">guy</span> <span class="title">fellow</span>[2] = &#123;</span></span><br><span class="line">		&#123;</span><br><span class="line">			&#123;<span class="string">"Ewen"</span>, <span class="string">"Villard"</span>&#125;,</span><br><span class="line">			<span class="string">"grilled salmon"</span>,</span><br><span class="line">			<span class="string">"personality coach"</span>,</span><br><span class="line">			<span class="number">68112.00</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&#123;<span class="string">"Rodney"</span>, <span class="string">"Swillbelly"</span>&#125;,</span><br><span class="line">			<span class="string">"tripe"</span>,</span><br><span class="line">			<span class="string">"tabloid editor"</span>,</span><br><span class="line">			<span class="number">432400.00</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">guy</span> * <span class="title">him</span>;</span></span><br><span class="line">		</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"address #1: %p #2: %p\n"</span>, &amp;fellow[<span class="number">0</span>], &amp;fellow[<span class="number">1</span>]);</span><br><span class="line">	him = &amp;fellow[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pointer #1: %p #2: %p\n"</span>, him, him + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"him-&gt;income is $%.2f: (*him).income is $%.2f\n"</span>, him-&gt;income, (*him).income);</span><br><span class="line">	him++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"him-&gt;favfood is $%.2f: him-&gt;handle.last is $%.2f\n"</span>, him-&gt;favfood, him-&gt;handle.last);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">address #<span class="number">1</span>: <span class="number">000000000062F</span>D60 #<span class="number">2</span>: <span class="number">000000000062F</span>DB4</span><br><span class="line">pointer #<span class="number">1</span>: <span class="number">000000000062F</span>D60 #<span class="number">2</span>: <span class="number">000000000062F</span>DB4</span><br><span class="line">him-&gt;income is $<span class="number">68112.00</span>: (*him).income is $<span class="number">68112.00</span></span><br><span class="line">him-&gt;favfood is $<span class="number">0.00</span>: him-&gt;handle.last is $<span class="number">0.00</span></span><br></pre></td></tr></table></figure>
<h4 id="声明和初始化结构指针"><a href="#声明和初始化结构指针" class="headerlink" title="声明和初始化结构指针"></a>声明和初始化结构指针</h4><code>struct guy * him;</code>  </li>
<li>指针现在可以指向任何guy类型的结构，和数组不同，结构变量名并不是结构的地址，因此要在结构变量名前面加上“&amp;”运算符，如果barnery是一个guy类型的结构变量，可以这样写：<br>  <code>him = &amp;barnery;</code>  </li>
<li>在本例中，fellow是一个结构数组，这意味着fellow[0]是一个结构，所以要让him指向fellow[0]，可以这样写：<br>  <code>him = &amp;fellow[0];</code>  <h4 id="用指针访问成员"><a href="#用指针访问成员" class="headerlink" title="用指针访问成员"></a>用指针访问成员</h4><blockquote>
<p>“.”的左操作数是一个结果为结构的表达式<br>“-&gt;”的左操作数是指向结构体的指针  </p>
<ul>
<li>思考：指针him指向结构变量fellow[0]，如何通过him获得fellow[0]的成员的值呢？  </li>
</ul>
<ol>
<li>使用-&gt;运算符  <ul>
<li>如果<code>him == &amp;barney</code>，那么<code>him-&gt;income</code>即是<code>barney.income</code>  </li>
<li>如果<code>him == &amp;fellow[0]</code>，那么<code>him-&gt;income</code>即是<code>fellow[0].income</code>  </li>
</ul>
</li>
<li>“<em>”和“&amp;”是互逆运算符<br> `fellow[0].income == (</em>him).income`</li>
</ol>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言, 数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>指针用法</title>
    <url>/2019/11/12/%E6%8C%87%E9%92%88%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="指针基础用法"><a href="#指针基础用法" class="headerlink" title="指针基础用法"></a>指针基础用法</h1><ol>
<li>声明指针：<code>int * pi; //表示指向int类型变量的指针</code><ol>
<li>指针用于储存变量的地址。  </li>
<li>*和指针名之间的空格：声明时使用空格，在解引用变量时省略空格。  </li>
</ol>
</li>
<li>关于指针的符号：&amp;和*<br> &amp;变量名：给出变量的储存地址<br> *：解引用运算符  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ptr = &amp;bah;  </span><br><span class="line">val = *ptr;</span><br><span class="line">//val = ptr;两种写法等价</span><br></pre></td></tr></table></figure>
<h1 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h1><h2 id="指针与一维数组"><a href="#指针与一维数组" class="headerlink" title="指针与一维数组"></a>指针与一维数组</h2></li>
</ol>
<ul>
<li>数组名是数组首元素的地址  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//array是一个数组</span><br><span class="line">array == &amp;array[0];</span><br></pre></td></tr></table></figure></li>
<li>数组与指针的关系  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">short</span> dates[SIZE];</span><br><span class="line">	<span class="keyword">short</span> * pti;</span><br><span class="line">	<span class="keyword">short</span> index;</span><br><span class="line">	<span class="keyword">double</span> bills[SIZE];</span><br><span class="line">	<span class="keyword">double</span> * ptf;</span><br><span class="line">	</span><br><span class="line">	pti = dates;</span><br><span class="line">	ptf = bills;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%23s %15s\n"</span>, <span class="string">"short"</span>, <span class="string">"double"</span>);</span><br><span class="line">	<span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; SIZE; index++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pointers + %d: %10p %10p\n"</span>, index, pti + index, ptf + index);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">                  <span class="keyword">short</span>          <span class="keyword">double</span></span><br><span class="line">pointers + <span class="number">0</span>: <span class="number">000000000062F</span>E00 <span class="number">000000000062F</span>DE0</span><br><span class="line">pointers + <span class="number">1</span>: <span class="number">000000000062F</span>E02 <span class="number">000000000062F</span>DE8</span><br><span class="line">pointers + <span class="number">2</span>: <span class="number">000000000062F</span>E04 <span class="number">000000000062F</span>DF0</span><br><span class="line">pointers + <span class="number">3</span>: <span class="number">000000000062F</span>E06 <span class="number">000000000062F</span>DF8</span><br></pre></td></tr></table></figure>
a. 在系统中，地址按字节编址，short占2字节，double占8字节。<br>b. 在C中，指针加1指增加一个存储单元。<br>c. 因此对数组意味着加1后地址是下一元素的地址  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dates + 2 == &amp;dates[2];</span><br><span class="line">*(dates + 2) == dates[2];</span><br></pre></td></tr></table></figure></li>
<li>间接运算符(*)优先级高于+  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*(dates + 2)    //dates数组的第三个元素</span><br><span class="line">*dates + 2      //dates第一个元素的值加2</span><br></pre></td></tr></table></figure></li>
<li>一元运算符*和++优先级相同，但结合律是从右向左，因此<code>*start++</code>,是先对++求值再*运算。  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">2</span>] = &#123;<span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> moredata[<span class="number">2</span>] = &#123;<span class="number">300</span>, <span class="number">400</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> * p1;</span><br><span class="line">	<span class="keyword">int</span> * p2;</span><br><span class="line">	<span class="keyword">int</span> * p3;</span><br><span class="line">	p1 = p2 = data;</span><br><span class="line">	p3 = moredata;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  *p1 = %d,   *p2 = %d,   *p3 = %d\n"</span>, *p1, *p2, *p3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*p1++ = %d, *++p2 = %d, (*p3)++ = %d\n"</span>, *p1++, *++p2, (*p3)++);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  *p1 = %d,   *p2 = %d,   *p3 = %d\n"</span>, *p1, *p2, *p3);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">  *p1 = <span class="number">100</span>,   *p2 = <span class="number">100</span>,   *p3 = <span class="number">300</span></span><br><span class="line">*p1++ = <span class="number">100</span>, *++p2 = <span class="number">200</span>, (*p3)++ = <span class="number">300</span></span><br><span class="line">  *p1 = <span class="number">200</span>,   *p2 = <span class="number">200</span>,   *p3 = <span class="number">301</span></span><br></pre></td></tr></table></figure>
<h2 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int zippo[4][2];</span><br><span class="line">zippo == &amp;zippo[0];</span><br><span class="line">zippo[0] == &amp;zippo[0][0];</span><br><span class="line"></span><br><span class="line">//因此zippo == zippo[0];</span><br></pre></td></tr></table></figure></li>
<li>zippo[0]是一个占用一个int大小的对象的地址，zippo是一个占用两个int大小对象的地址。  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*zippo == zippo[<span class="number">0</span>];</span><br><span class="line">**zippo == zippo[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure></li>
<li>加一个*解一层引用  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zippo[4][2] = &#123;&#123;2, 4&#125;, &#123;6, 8&#125;, &#123;1, 3&#125;, &#123;5, 7&#125;&#125;;</span><br></pre></td></tr></table></figure></li>
<li>zippo + 2 == 6;<br><em>(zippo + 2) == 6;<br>*(zippo + 2) + 1 == 8;<br>\</em>(*(zippo + 2) + 1) == 3;  <h2 id="指向多维数组的指针（列指针）"><a href="#指向多维数组的指针（列指针）" class="headerlink" title="指向多维数组的指针（列指针）"></a>指向多维数组的指针（列指针）</h2><code>int (*pz)[2];</code>  </li>
<li>该声明表示pz指向一个内含两个int类型值得数组</li>
</ul>
<p><code>int * pax[2];</code>  </p>
<ul>
<li>pax是一个内含两个指针元素的数组，每个元素都指向int的指针  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> zippo[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">2</span>, <span class="number">4</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">5</span>, <span class="number">7</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> (*pz)[<span class="number">2</span>];</span><br><span class="line">	pz = zippo;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  pz = %p,   pz + 1 = %p\n"</span>,   pz, pz + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pz[0] = %p, pz[0] + 1 = %p\n"</span>, pz[<span class="number">0</span>], pz[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" *pz = %p,   *pz + 1 = %p\n"</span>,  *pz, *pz + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pz[0][0] = %d\n"</span>, pz[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" *pz[0] = %d\n"</span>, *pz[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   **pz = %d\n"</span>, **pz);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"     pz[2][1] = %d\n"</span>, pz[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*(*(pz + 2) + 1) = %d\n"</span>, *(*(pz + <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">  pz = <span class="number">000000000062F</span>DF0,   pz + <span class="number">1</span> = <span class="number">000000000062F</span>DF8</span><br><span class="line">pz[<span class="number">0</span>] = <span class="number">000000000062F</span>DF0, pz[<span class="number">0</span>] + <span class="number">1</span> = <span class="number">000000000062F</span>DF4</span><br><span class="line"> *pz = <span class="number">000000000062F</span>DF0,   *pz + <span class="number">1</span> = <span class="number">000000000062F</span>DF4</span><br><span class="line">pz[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"> *pz[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">   **pz = <span class="number">2</span></span><br><span class="line">     pz[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">*(*(pz + <span class="number">2</span>) + <span class="number">1</span>) = <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li>列指针进行&amp;运算变为行指针，行指针进行*运算变为列指针。</li>
</ul>
]]></content>
      <categories>
        <category>C语言, 数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog</title>
    <url>/2019/11/11/Blog/</url>
    <content><![CDATA[<h1 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h1><p>hello blog</p>
]]></content>
  </entry>
</search>
